"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["6787"],{76567:function(e,n,i){i.r(n),i.d(n,{metadata:()=>s,contentTitle:()=>o,default:()=>h,assets:()=>c,toc:()=>l,frontMatter:()=>a});var s=JSON.parse('{"id":"dev/internals/copytracing","title":"Bisect-Based Copy Tracing","description":"Copy tracing is a technique used to efficiently account for file copies and","source":"@site/docs/dev/internals/copytracing.md","sourceDirName":"dev/internals","slug":"/dev/internals/copytracing","permalink":"/docs/dev/internals/copytracing","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/sapling/tree/main/website/docs/dev/internals/copytracing.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Internals","permalink":"/docs/category/internals"},"next":{"title":"DrawDag","permalink":"/docs/dev/internals/drawdag"}}'),t=i("85893"),r=i("50065");let a={},o="Bisect-Based Copy Tracing",c={},l=[{value:"Background",id:"background",level:2},{value:"How?",id:"how",level:2},{value:"Scalability",id:"scalability",level:3},{value:"Flexibility",id:"flexibility",level:3},{value:"Abstracted",id:"abstracted",level:3},{value:"Efficiency",id:"efficiency",level:3},{value:"User-Friendly",id:"user-friendly",level:3}];function d(e){let n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"bisect-based-copy-tracing",children:"Bisect-Based Copy Tracing"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Copy tracing"})," is a technique used to efficiently account for file copies and\nrenames when comparing histories. It is used for ",(0,t.jsx)(n.code,{children:"diff"})," commands and merge-related\noperations, such as ",(0,t.jsx)(n.code,{children:"rebase"}),", ",(0,t.jsx)(n.code,{children:"graft"}),", and ",(0,t.jsx)(n.code,{children:"merge"}),". It simplifies resolving merge conflicts,\nespecially when large refactors, like directory renames, occur in frequently updated\nrepositories. Below is an example of a rebase involving file renames:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sl-shell-example",children:"$ sl\n@  d78558192  1 second ago  alyssa\n\u2502  update b\n\u2502\no  2b089a0d8  15 seconds ago  alyssa\n\u2502  mv a -> b\n\u2502\n\u2502 o  b0d1b083d  36 seconds ago  alyssa\n\u251C\u2500\u256F  update a\n\u2502\no  5b0d97d5a  46 seconds ago  alyssa\n   add a\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Without copy tracing, ",(0,t.jsx)(n.code,{children:"sl"})," previously had to ask about renamed or copied files\nduring rebases:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sl-shell-example",children:'$ sl rebase -s b0d1b083d -d d78558192\nrebasing b0d1b083d791 "update a"\nother [source (being rebased)] changed a which local [dest (rebasing onto)] is missing\nhint: if this is due to a renamed file, you can manually input the renamed path\nuse (c)hanged version, leave (d)eleted, or leave (u)nresolved, or input (r)enamed path?\n'})}),"\n",(0,t.jsxs)(n.p,{children:["With copy tracing, the merge ",(0,t.jsx)(n.em,{children:"just works"}),", despite there being copied or renamed\nfiles:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sl-shell-example",children:'$ sl rebase -s b0d1b083d -d d78558192\nrebasing b0d1b083d791 "update a"\nmerging b and a to b\nb0d1b083d791 -> 92444cbb366b "update a"\n'})}),"\n",(0,t.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,t.jsxs)(n.p,{children:["Historically, Sapling has used two copy-tracing solutions. However, as our\nmonorepos grow (",(0,t.jsx)(n.a,{href:"https://engineering.fb.com/2022/11/15/open-source/sapling-source-control-scalable/",children:"tens of millions of files, tens of millions of commits"}),"),\nthe previous solutions have become too slow for production use:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Full copy tracing"})," finds all the new files (M) that were added from\nmerge base up to the top commit and for each file it checks if this file\nwas copied from another file (N). For each pair of files, Sapling was walking\nthrough the file history (H) to check the copy-from the relationship.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The time complexity of this algorithm is ",(0,t.jsx)(n.code,{children:"O(M * N * H)"}),", where N and H are huge.","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Typically M (source) << N (destination)"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"Sapling records rename information directly in file headers, eliminating the\nneed to compute file content similarity, which is different from Git's approach."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Heuristics copy tracing"})," assumes that moves or renames fall into one of two\ncategories: (1) Within the same directory (same directory name but different\nfile names); (2) Move from one directory to another (same file names but\ndifferent directory names)","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["This approach reduces N to K (K is a configured constant value), resulting\nin a time complexity of ",(0,t.jsx)(n.code,{children:"O(M * H)"}),", where H remains large and there is a large\nconstant factor for reducing N to K."]}),"\n",(0,t.jsx)(n.li,{children:"Another issue is that if the renames do not match the heuristics, they\ncannot be found."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Before we explore bisect-based copy tracing, let's first examine how\n",(0,t.jsx)(n.a,{href:"https://github.com/newren/presentations/blob/pdfs/merge-performance/merge-performance-slides.pdf",children:"Git's rename detection"}),'\nworks. Git\'s rename detection is similar to the heuristics copy tracing\nmentioned earlier, but it includes additional heuristics and strategies\nto enhance performance, such as "Remembering previous work", "Exact renames".']}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The time complexity is ",(0,t.jsx)(n.code,{children:"O(M * S)"}),", where M is the same as above,\nS is the complexity of file content similarity computation."]}),"\n",(0,t.jsxs)(n.li,{children:["It also shares the disadvantage of Sapling heuristics copy tracing\nwhen renames do not match heuristics. Otherwise, the time complexity\nwill be ",(0,t.jsx)(n.code,{children:"O(M * N * S)"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Bisect-based copy tracing is built to achieve the following desired properties:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scalability"}),": ",(0,t.jsx)(n.code,{children:"O(M * log H)"})," time complexity, it bisects the file history\nrather than scanning commits sequentially."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Flexibility"}),": Not restricted by heuristics like 'Move from one directory to another'."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Abstracted"}),": Support both Sapling and Git backend repositories."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Efficiency"}),": Provides fast content similarity checks for cases where renames\nare not recorded in Sapling or when working with Git repositories."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"User-Friendly"}),": Informative message when renames cannot be found, such as\ndelete/modified conflicts."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"how",children:"How?"}),"\n",(0,t.jsx)(n.h3,{id:"scalability",children:"Scalability"}),"\n",(0,t.jsxs)(n.p,{children:["The problem that copy tracing solves is: ",(0,t.jsx)(n.strong,{children:"given two commits, C1 and C2, and a path P1 in C1, we need to find the renamed path P2 in C2"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"This problem required a new algorithmic design to scale efficiently. The\nbasic idea is to break the problem into two steps:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Bisect a commit ",(0,t.jsx)(n.code,{children:"C3"})," that deletes ",(0,t.jsx)(n.code,{children:"P1"})," in the ",(0,t.jsx)(n.code,{children:"C1"})," to ",(0,t.jsx)(n.code,{children:"C2"})," range."]}),"\n",(0,t.jsxs)(n.li,{children:["Examine ",(0,t.jsx)(n.code,{children:"C3"}),", find what path ",(0,t.jsx)(n.code,{children:"P1"})," was renamed to. If that path exists in ",(0,t.jsx)(n.code,{children:"C2"}),",\nthen we\u2019re done. Otherwise recursively trace renames in the ",(0,t.jsx)(n.code,{children:"C3"})," to ",(0,t.jsx)(n.code,{children:"C2"})," range."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The efficient bisect is based on the ",(0,t.jsx)(n.a,{href:"https://github.com/facebook/sapling/blob/main/eden/scm/slides/201904-segmented-changelog/segmented-changelog.pdf",children:"Segmented Changelog"})," we developed for lazy commit graph downloading and improving DAG operations,\nplease check ",(0,t.jsx)(n.a,{href:"https://engineering.fb.com/2022/11/15/open-source/sapling-source-control-scalable/",children:"this blog post"}),"\nto learn more about Segmented Changelog."]}),"\n",(0,t.jsx)(n.h3,{id:"flexibility",children:"Flexibility"}),"\n",(0,t.jsx)(n.p,{children:"Since Sapling can efficiently trace rename commits by bisecting the history,\nand then find the renames in a rename commit, we don't need heuristics to\nreduce the large number N on destination side. This approach allows Sapling\nto detect renames that would otherwise be missed by heuristics-based methods."}),"\n",(0,t.jsx)(n.h3,{id:"abstracted",children:"Abstracted"}),"\n",(0,t.jsx)(n.p,{children:"We made the rename detection inside a commit abstracted. Whether it\u2019s Sapling\u2019s\ntracked rename, or Git\u2019s implicit content similar rename, or a combination\nof them, they fit in the same abstraction and can be flexibly configured."}),"\n",(0,t.jsx)(n.h3,{id:"efficiency",children:"Efficiency"}),"\n",(0,t.jsxs)(n.p,{children:["Typical content similarity libraries often degrade to ",(0,t.jsx)(n.code,{children:"O(N^2)"})," in the worst case,\nwhere N is the line count (",(0,t.jsx)(n.code,{children:"O(N^2)"})," is the worst case for the Myers diff algorithm).\nOur approach, ",(0,t.jsx)(n.code,{children:"xdiff::edit_cost"}),", imposes a ",(0,t.jsx)(n.code,{children:"max cost"})," limit, reducing the\ncomplexity to ",(0,t.jsx)(n.code,{children:"O(N)"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"user-friendly",children:"User-Friendly"}),"\n",(0,t.jsxs)(n.p,{children:["When renames cannot be found, for example, file ",(0,t.jsx)(n.code,{children:"a.txt"})," was renamed to ",(0,t.jsx)(n.code,{children:"a.md"}),"\nand then deleted on the destination branch, the new copy tracing can identify\nboth the commit that renamed the file and also the commit that eventually\ndeleted it. This allows us to provide additional context to help resolve the\nconflict:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sl-shell-example",children:"$ sl rebase -s 108b59d42 -d a1fcdc96b\n...\nother [source (being rebased)] changed a.txt which local [dest (rebasing onto)] is missing\nhint: the missing file was probably deleted by commit 7f48dc97d540 with name 'a.md' in the branch rebasing onto\nuse (c)hanged version, leave (d)eleted, or leave (u)nresolved, or input (r)enamed path?\n"})})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},50065:function(e,n,i){i.d(n,{Z:function(){return o},a:function(){return a}});var s=i(67294);let t={},r=s.createContext(t);function a(e){let n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);