"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2020],{3905:(e,t,i)=>{i.r(t),i.d(t,{MDXContext:()=>l,MDXProvider:()=>u,mdx:()=>f,useMDXComponents:()=>d,withMDXComponents:()=>c});var n=i(67294);function o(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function a(){return a=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var i=arguments[t];for(var n in i)Object.prototype.hasOwnProperty.call(i,n)&&(e[n]=i[n])}return e},a.apply(this,arguments)}function r(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function s(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?r(Object(i),!0).forEach((function(t){o(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function m(e,t){if(null==e)return{};var i,n,o=function(e,t){if(null==e)return{};var i,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||(o[i]=e[i]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(o[i]=e[i])}return o}var l=n.createContext({}),c=function(e){return function(t){var i=d(t.components);return n.createElement(e,a({},t,{components:i}))}},d=function(e){var t=n.useContext(l),i=t;return e&&(i="function"==typeof e?e(t):s(s({},t),e)),i},u=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var i=e.components,o=e.mdxType,a=e.originalType,r=e.parentName,l=m(e,["components","mdxType","originalType","parentName"]),c=d(i),u=o,p=c["".concat(r,".").concat(u)]||c[u]||h[u]||a;return i?n.createElement(p,s(s({ref:t},l),{},{components:i})):n.createElement(p,s({ref:t},l))}));function f(e,t){var i=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=i.length,r=new Array(a);r[0]=p;var s={};for(var m in t)hasOwnProperty.call(t,m)&&(s[m]=t[m]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var l=2;l<a;l++)r[l]=i[l];return n.createElement.apply(null,r)}return n.createElement.apply(null,i)}p.displayName="MDXCreateElement"},920:(e,t,i)=>{i.d(t,{RJ:()=>l,Xj:()=>s,bv:()=>m,mY:()=>r,nk:()=>c});var n=i(67294),o=i(44996),a=i(50941);function r(e){let{name:t,linkText:i}=e;const a=function(e){switch(e){case"go":return"goto";case"isl":return"web"}return e}(t),r=null!=i?i:t;return n.createElement("a",{href:(0,o.default)("/docs/commands/"+a)},n.createElement("code",null,r))}function s(e){let{name:t}=e;return n.createElement(r,{name:t,linkText:"sl "+t})}function m(){return n.createElement("p",{style:{textAlign:"center"}},n.createElement("img",{src:(0,o.default)("/img/reviewstack-demo.gif"),width:800,align:"center"}))}function l(e){let{alt:t,light:i,dark:r}=e;return n.createElement(a.Z,{alt:t,sources:{light:(0,o.default)(i),dark:(0,o.default)(r)}})}function c(e){let{src:t}=e;return n.createElement("video",{controls:!0},n.createElement("source",{src:(0,o.default)(t)}))}},10623:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>m,toc:()=>c});var n=i(83117),o=(i(67294),i(3905)),a=i(920);const r={},s="Visibility and mutation",m={unversionedId:"dev/internals/visibility-and-mutation",id:"dev/internals/visibility-and-mutation",title:"Visibility and mutation",description:"The way Sapling tracks which commits are visible to an individual developer, and how it tracks the ways in which commits have been mutated, differs from other source control systems.  Designing a system to allow mutations of the otherwise immutable commit graph brings its own scaling challenges.  This document describes the way these have been addressed in Sapling.",source:"@site/docs/dev/internals/visibility-and-mutation.md",sourceDirName:"dev/internals",slug:"/dev/internals/visibility-and-mutation",permalink:"/docs/dev/internals/visibility-and-mutation",draft:!1,editUrl:"https://github.com/facebook/sapling/tree/main/website/docs/dev/internals/visibility-and-mutation.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"MetaLog",permalink:"/docs/dev/internals/metalog"},next:{title:"ZstDelta",permalink:"/docs/dev/internals/zstdelta"}},l={},c=[{value:"Commit visibility",id:"commit-visibility",level:2},{value:"Commit mutation",id:"commit-mutation",level:2}],d={toc:c};function u(e){let{components:t,...i}=e;return(0,o.mdx)("wrapper",(0,n.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("h1",{id:"visibility-and-mutation"},"Visibility and mutation"),(0,o.mdx)("p",null,"The way Sapling tracks which commits are visible to an individual developer, and how it tracks the ways in which commits have been mutated, differs from other source control systems.  Designing a system to allow mutations of the otherwise immutable commit graph brings its own scaling challenges.  This document describes the way these have been addressed in Sapling."),(0,o.mdx)("h2",{id:"commit-visibility"},"Commit visibility"),(0,o.mdx)("p",null,"A Sapling repository can contain more commits than the commits you're currently working on.  For example, when you amend a commit, the old version of the commit remains in the repository.  You can still access it directly using its hash, but otherwise the commit is ",(0,o.mdx)("em",{parentName:"p"},"hidden"),"."),(0,o.mdx)("p",null,"Sapling tracks visibility of commits in a couple of ways:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"Any commit that is an ancestor of a remote bookmark is visible.  These commits are public and cannot be modified."),(0,o.mdx)("li",{parentName:"ul"},"Sapling also tracks a set of visible heads.  Any commit that is an ancestor of a visible head is visible.  These commits are draft, and may be modified by commands like ",(0,o.mdx)(a.Xj,{name:"amend",mdxType:"SLCommand"}),".  When a commit is created or modified, Sapling automatically removes any old versions of the commits from this set, and adds the new ones to it.")),(0,o.mdx)("p",null,"This is similar to how Git tracks which commits are reachable in the repository using the local and remote branches, except that Sapling maintains your local branches for you automatically."),(0,o.mdx)("p",null,"While most visibility operations are automatic, you can also manually hide and unhide commits using the ",(0,o.mdx)(a.Xj,{name:"hide",mdxType:"SLCommand"})," and ",(0,o.mdx)(a.Xj,{name:"unhide",mdxType:"SLCommand"})," commands."),(0,o.mdx)("p",null,"In order to scale to thousands of developers contributing to the same repository, commit visibility is entirely local.  Which commits are visible to you are not shared with other developers, so if you hide a commit, it is only hidden for you."),(0,o.mdx)("h2",{id:"commit-mutation"},"Commit mutation"),(0,o.mdx)("p",null,"Sapling tracks whenever commits are modified using commands like rebase or amend.  The records of these changes are called ",(0,o.mdx)("em",{parentName:"p"},"mutations"),"."),(0,o.mdx)("p",null,"This is similar to some parts of the ",(0,o.mdx)("em",{parentName:"p"},"Evolve")," extension of Mercurial, however it is designed to be more lightweight to allow scaling to very large repositories with millions of modified commits."),(0,o.mdx)("p",null,"A mutation record is a record of how a modified commit came to exist.  For example, if you run ",(0,o.mdx)(a.Xj,{name:"amend",mdxType:"SLCommand"}),' on commit A to produce commit B, Sapling will store a record that says "commit B was created by amending commit A".  It will also record who performed the mutation, and the timestamp.'),(0,o.mdx)("p",null,"For the most part, mutation records are purely informational.  They affect Sapling operations in two ways:"),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},"In smartlog, if both a commit that has been modified and its modified version are visible, the earlier commit will show as ",(0,o.mdx)("em",{parentName:"li"},"obsolete")," and the latest version's hash will be shown next to the commit, along with whatever operation caused the modification."),(0,o.mdx)("li",{parentName:"ul"},"When restacking commits after modifying a commit in the middle of stack, Sapling will use the mutation information of a commit's parent to determine the latest commits that should be used as the destination for each restack.")),(0,o.mdx)("p",null,"You can also find earlier and later versions of a commit using the ",(0,o.mdx)("inlineCode",{parentName:"p"},"predecessors")," and ",(0,o.mdx)("inlineCode",{parentName:"p"},"successors")," revsets."),(0,o.mdx)("p",null,"When used with the Sapling server, commit mutation information can be shared with other developers working on the same commits. When pushing or pulling draft commits to or from the server, Sapling includes records covering the full mutation history of the pushed or pulled commits.  It's not necessary for the older commits themselves to be shared, as Sapling can skip over commits in the history that are not present in the local repository.  In order for this to scale to thousands of developers making millions of changes, Sapling only considers mutation records in the mutation history of the draft commits that you are currently working on, i.e., those that are visible in your local repository."))}u.isMDXComponent=!0}}]);