"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["279"],{56329:function(e,o,n){n.r(o),n.d(o,{metadata:()=>i,contentTitle:()=>r,default:()=>h,assets:()=>l,toc:()=>c,frontMatter:()=>s});var i=JSON.parse('{"id":"introduction/differences-git","title":"Differences from Git","description":"While Sapling is similar to Git in that it is distributed, uses hash-addressed commits, has branches (called bookmarks), and uses a clone/pull/push/commit/rebase model, there are a number of behavioral differences.","source":"@site/docs/introduction/differences-git.md","sourceDirName":"introduction","slug":"/introduction/differences-git","permalink":"/docs/introduction/differences-git","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/sapling/tree/main/website/docs/introduction/differences-git.md","tags":[],"version":"current","sidebarPosition":40,"frontMatter":{"sidebar_position":40},"sidebar":"tutorialSidebar","previous":{"title":"Git cheat sheet","permalink":"/docs/introduction/git-cheat-sheet"},"next":{"title":"Differences from Mercurial","permalink":"/docs/introduction/differences-hg"}}'),a=n("85893"),t=n("50065");let s={sidebar_position:40},r="Differences from Git",l={},c=[{value:"Sapling does not require or encourage using named local branches.",id:"sapling-does-not-require-or-encourage-using-named-local-branches",level:4},{value:"Sapling has no staging area.",id:"sapling-has-no-staging-area",level:4},{value:"Sapling may not download all the repository data during clone/pull.",id:"sapling-may-not-download-all-the-repository-data-during-clonepull",level:4},{value:"Sapling has first-class support for undo commands.",id:"sapling-has-first-class-support-for-undo-commands",level:4},{value:"Sapling does not use <code>rebase -i</code> for editing stacked commits.",id:"sapling-does-not-use-rebase--i-for-editing-stacked-commits",level:4},{value:"Sapling generally does one thing per command.",id:"sapling-generally-does-one-thing-per-command",level:4},{value:"Sapling allows pushing \u201Conto\u201D a bookmark (when used with a Sapling compatible server).",id:"sapling-allows-pushing-onto-a-bookmark-when-used-with-a-sapling-compatible-server",level:4},{value:"Sapling supports \u201Csparse profiles\u201D for sharing sparse configuration (when not using the Sapling virtual filesystem).",id:"sapling-supports-sparse-profiles-for-sharing-sparse-configuration-when-not-using-the-sapling-virtual-filesystem",level:4},{value:"Sapling tracks the history of a commit as it\u2019s changed over time.",id:"sapling-tracks-the-history-of-a-commit-as-its-changed-over-time",level:4}];function d(e){let o={a:"a",code:"code",h1:"h1",h4:"h4",header:"header",p:"p",...(0,t.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(o.header,{children:(0,a.jsx)(o.h1,{id:"differences-from-git",children:"Differences from Git"})}),"\n",(0,a.jsx)(o.p,{children:"While Sapling is similar to Git in that it is distributed, uses hash-addressed commits, has branches (called bookmarks), and uses a clone/pull/push/commit/rebase model, there are a number of behavioral differences."}),"\n",(0,a.jsx)(o.p,{children:"The list of differences below is not comprehensive, nor is it meant to be a competitive comparison of Git and Sapling. Rather, it highlights some interesting differences for curious people who are already familiar with Git. Sapling has substantial scaling differences as well, which are not covered here."}),"\n",(0,a.jsx)(o.h4,{id:"sapling-does-not-require-or-encourage-using-named-local-branches",children:"Sapling does not require or encourage using named local branches."}),"\n",(0,a.jsx)(o.p,{children:"In Git, your repository is defined by the location of your branches, and you pretty much must be on a local branch whenever you do work. In addition, any amend/rebase you do to one branch has no impact on any other branch."}),"\n",(0,a.jsx)(o.p,{children:'In Sapling, local bookmarks (the equivalent to a Git branch) are completely optional and generally not even used. You do have "branches" in the sense that you can make a stack of commits that fork off the main line of the commit graph, but there is no need to put a label on it. All of your commits are easily visible in your \u201Csmartlog\u201D and can be accessed via its hash.'}),"\n",(0,a.jsx)(o.p,{children:"Instead of deleting a branch to delete commits, you can \u201Chide\u201D and \u201Cunhide\u201D commits. Not requiring bookmarks simplifies the mental model of the repo and has generally been well regarded by our users. Local bookmarks may still be used as a convenient label for commits, but note that rebasing a commit will move all local bookmarks along with the commit. Remote bookmarks are still required and are locally immutable, similar to origin/main in Git."}),"\n",(0,a.jsx)(o.h4,{id:"sapling-has-no-staging-area",children:"Sapling has no staging area."}),"\n",(0,a.jsx)(o.p,{children:"In Git, you must add changes to the staging area before you commit them. This can be used to commit/amend just part of your changes."}),"\n",(0,a.jsxs)(o.p,{children:["In Sapling, there is no staging area. If you want to commit/amend just part of your changes you can use ",(0,a.jsx)(o.code,{children:"commit/amend -i"})," to interactively choose which changes to commit/amend. Alternatively, you can simulate a staging area by making a temporary commit and amending to it as if it was the staging area, then use ",(0,a.jsx)(o.code,{children:"fold"})," to collapse it into the real commit."]}),"\n",(0,a.jsx)(o.h4,{id:"sapling-may-not-download-all-the-repository-data-during-clonepull",children:"Sapling may not download all the repository data during clone/pull."}),"\n",(0,a.jsx)(o.p,{children:"In Git, a clone or pull will generally fetch all new repository data."}),"\n",(0,a.jsxs)(o.p,{children:["In Sapling, a clone or pull will only fetch the main branches of a repo. Other branches will be fetched on demand. ",(0,a.jsx)(o.code,{children:"push"})," only updates one remote branch. When used with a supported server, Sapling might fetch commit data (messages, date, or even hashes), tree and file data on demand. These avoid downloading unnecessary data, at the cost of requiring the user to be online more often."]}),"\n",(0,a.jsx)(o.h4,{id:"sapling-has-first-class-support-for-undo-commands",children:"Sapling has first-class support for undo commands."}),"\n",(0,a.jsx)(o.p,{children:"In Git, to undo many operations requires a deeper understanding of the Git commit model and how git checkout/reset/reflog interact with that model."}),"\n",(0,a.jsxs)(o.p,{children:["In Sapling, there are ",(0,a.jsx)(o.code,{children:"uncommit"}),", ",(0,a.jsx)(o.code,{children:"unamend"}),", ",(0,a.jsx)(o.code,{children:"unhide"}),", and ",(0,a.jsx)(o.code,{children:"undo"})," commands for undoing common operations.  Additionally, ",(0,a.jsx)(o.code,{children:"undo -i"})," allows you to go back across multiple operations and gives a visual preview of the post-undo state of the repository before you do it."]}),"\n",(0,a.jsxs)(o.h4,{id:"sapling-does-not-use-rebase--i-for-editing-stacked-commits",children:["Sapling does not use ",(0,a.jsx)(o.code,{children:"rebase -i"})," for editing stacked commits."]}),"\n",(0,a.jsxs)(o.p,{children:["In Git, when working with a stack of commits, you are generally required to use ",(0,a.jsx)(o.code,{children:"git rebase -i"})," to edit commits in the middle of the stack, which is a notably complex flow."]}),"\n",(0,a.jsxs)(o.p,{children:["In Sapling, when working with a stack of commits you can just checkout the commit you want to work on and run \u201Camend\u201D, \u201Csplit\u201D, \u201Cfold\u201D, etc to modify the middle of the stack. The top of the stack is automatically kept track of and restacked for you so your stack remains together. Additionally, ",(0,a.jsx)(o.code,{children:"absorb"})," allows automatically sucking pending changes down into the appropriate commit in your stack. ",(0,a.jsx)(o.code,{children:"histedit"})," can be used to provide a ",(0,a.jsx)(o.code,{children:"rebase -i"})," like experience if desired."]}),"\n",(0,a.jsx)(o.h4,{id:"sapling-generally-does-one-thing-per-command",children:"Sapling generally does one thing per command."}),"\n",(0,a.jsxs)(o.p,{children:["In Git, a command may do multiple seemingly unrelated things. ",(0,a.jsx)(o.code,{children:"checkout"})," may be used to move to another commit, revert the contents of an individual file, and create a branch. ",(0,a.jsx)(o.code,{children:"reset"})," may be used to move a branch and undo certain operations. ",(0,a.jsx)(o.code,{children:"rebase"})," can be used to move commits or edit a stack."]}),"\n",(0,a.jsxs)(o.p,{children:["In Sapling, each command generally does one thing. ",(0,a.jsx)(o.code,{children:"pull"})," fetches remote commits without merging. ",(0,a.jsx)(o.code,{children:"goto"})," moves you to another commit. ",(0,a.jsx)(o.code,{children:"revert"})," adjusts the contents of files in the working copy. ",(0,a.jsx)(o.code,{children:"bookmark"})," create a bookmark. ",(0,a.jsx)(o.code,{children:"rebase"})," moves commits, etc."]}),"\n",(0,a.jsx)(o.h4,{id:"sapling-allows-pushing-onto-a-bookmark-when-used-with-a-sapling-compatible-server",children:"Sapling allows pushing \u201Conto\u201D a bookmark (when used with a Sapling compatible server)."}),"\n",(0,a.jsx)(o.p,{children:"In Git, pushing involves sending your commits to the server and updating the server branches to point at the new commits."}),"\n",(0,a.jsx)(o.p,{children:"In Sapling, when used with a Sapling compatible server, a push sends your commits to the server then the server rebases your commit onto the target bookmark (as long as the rebase would not require merging file changes) and moves the target bookmark forward.  This allows many pushes to succeed at once, without requiring people to pull-then-rebase-then-push again to win a push race."}),"\n",(0,a.jsx)(o.h4,{id:"sapling-supports-sparse-profiles-for-sharing-sparse-configuration-when-not-using-the-sapling-virtual-filesystem",children:"Sapling supports \u201Csparse profiles\u201D for sharing sparse configuration (when not using the Sapling virtual filesystem)."}),"\n",(0,a.jsx)(o.p,{children:"In Git, users are responsible for manually managing their own sparse configuration."}),"\n",(0,a.jsx)(o.p,{children:'In Sapling, sparse configuration can be checked into the repo as a "sparse profile" file which lists all the paths to include/exclude. This allows all users on a team or in an org to use the same sparse profile. As dependencies change, the shared profile can be updated so that everyone always has the correct files without every engineer having to update their setup.'}),"\n",(0,a.jsx)(o.h4,{id:"sapling-tracks-the-history-of-a-commit-as-its-changed-over-time",children:"Sapling tracks the history of a commit as it\u2019s changed over time."}),"\n",(0,a.jsx)(o.p,{children:"In Git, if you amend or rebase a file, there is no record that the new version of the commit came from the old version."}),"\n",(0,a.jsxs)(o.p,{children:["In Sapling, when you modify a commit via operations such as amend, rebase, fold, or split, the record of the operation is kept which allows you to view the mutation history of that commit. This history is used to automate certain rebases for you: for instance, if you have a stack of five commits and the first commit gets rebased and pushed to ",(0,a.jsx)(o.code,{children:"main"})," by your CI system, Sapling will know that your local commit ",(0,a.jsx)(o.a,{href:"https://github.com/facebook/sapling/issues/1",children:"#1"})," became commit X in ",(0,a.jsx)(o.code,{children:"main"})," and can automatically rebase commits 2-5 onto the new ",(0,a.jsx)(o.code,{children:"main"})," version. The record of the mutations becomes particularly powerful when working across multiple machines or with multiple people on a stack, as it allows the stack to stay together even as different people/machines edit different parts of it."]})]})}function h(e={}){let{wrapper:o}={...(0,t.a)(),...e.components};return o?(0,a.jsx)(o,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},50065:function(e,o,n){n.d(o,{Z:function(){return r},a:function(){return s}});var i=n(67294);let a={},t=i.createContext(a);function s(e){let o=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(o):{...o,...e}},[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(t.Provider,{value:o},e.children)}}}]);