"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4534],{3905:(e,t,n)=>{n.r(t),n.d(t,{MDXContext:()=>c,MDXProvider:()=>u,mdx:()=>p,useMDXComponents:()=>h,withMDXComponents:()=>d});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(){return i=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},i.apply(this,arguments)}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),d=function(e){return function(t){var n=h(t.components);return a.createElement(e,i({},t,{components:n}))}},h=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=h(e.components);return a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=h(n),u=o,g=d["".concat(r,".").concat(u)]||d[u]||m[u]||i;return n?a.createElement(g,s(s({ref:t},c),{},{components:n})):a.createElement(g,s({ref:t},c))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=g;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},19658:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(83117),o=(n(67294),n(3905));const i={sidebar_position:30},r="Organizational scale",s={unversionedId:"scale/organizational",id:"scale/organizational",title:"Organizational scale",description:"Scale is often thought of as simply a technical matter: handle more data, and do it quickly.  Much less is said about the challenges organizational scale introduces on developer tools.  Over the past 10 years Sapling has encountered these challenges as the number of engineers has grown, as business needs have shifted, and as large repositories have been merged.",source:"@site/docs/scale/organizational.md",sourceDirName:"scale",slug:"/scale/organizational",permalink:"/docs/scale/organizational",draft:!1,editUrl:"https://github.com/facebookexperimental/eden/tree/main/website/docs/scale/organizational.md",tags:[],version:"current",sidebarPosition:30,frontMatter:{sidebar_position:30},sidebar:"tutorialSidebar",previous:{title:"Axes of scale",permalink:"/docs/scale/axes"},next:{title:"Sapling Developer Guide",permalink:"/docs/dev/"}},l={},c=[{value:"Scaling customer support",id:"scaling-customer-support",level:3},{value:"Managing configuration",id:"managing-configuration",level:3},{value:"Incremental migrations",id:"incremental-migrations",level:3},{value:"Metrics and logging",id:"metrics-and-logging",level:3}],d={toc:c};function h(e){let{components:t,...n}=e;return(0,o.mdx)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.mdx)("h1",{id:"organizational-scale"},"Organizational scale"),(0,o.mdx)("p",null,"Scale is often thought of as simply a technical matter: handle more data, and do it quickly.  Much less is said about the challenges organizational scale introduces on developer tools.  Over the past 10 years Sapling has encountered these challenges as the number of engineers has grown, as business needs have shifted, and as large repositories have been merged."),(0,o.mdx)("p",null,"This document is a high-level overview of some of the strategies we\u2019ve found useful."),(0,o.mdx)("h3",{id:"scaling-customer-support"},"Scaling customer support"),(0,o.mdx)("p",null,"When you have thousands of engineers, every edge case will be hit and strange issues from strange environments will need to be debugged.  To stay on top of this, the Sapling team developed tools to make it easier to debug engineer issues quickly. Note, some of these are not available by default in the open source release since they require logging and services that only make sense within an organization."),(0,o.mdx)("ul",null,(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"sl doctor")," is a command that attempts to fix a number of known issues, such as repository corruption. As new issues are found, ",(0,o.mdx)("inlineCode",{parentName:"li"},"sl doctor")," is updated to fix them, which allows engineers to self-remediate many issues, thereby helping reduce the support burden on the Sapling team."),(0,o.mdx)("li",{parentName:"ul"},(0,o.mdx)("inlineCode",{parentName:"li"},"sl rage")," is a command that gathers state about the engineer\u2019s source control environment and creates a human readable text file with the information.  It contains hostname, filesystem, disk usage, smartlog/status output, configuration, and recent commands, logs, errors, and profiles.  This information allows the engineer to provide us with all the data we need without having to have a bunch of back and forths.  The version of Sapling used inside Meta automatically uploads the rage file to a server for easy viewing by the Sapling team. The open source version does not upload any data."),(0,o.mdx)("li",{parentName:"ul"},"If an engineer complains about a slow command, adding ",(0,o.mdx)("inlineCode",{parentName:"li"},"--profile")," to any command allows them to produce a profile in the output. This makes it easy for the Sapling team to identify where the problem is, without having access to their machine or walking the engineer through how to use a profiler.  If a command is hung, a similar traceback is written to .sl/sigtraces/ every 60 seconds, allowing us to see exactly where the current process is stuck.  These tools make debugging tricky performance issues much easier, especially in a distributed environment.")),(0,o.mdx)("h3",{id:"managing-configuration"},"Managing configuration"),(0,o.mdx)("p",null,"Configuration is a critical part of the Sapling experience at Meta and plays a large part in how we roll out new features.  In the past we used a hierarchy of configuration files (similar to a ",(0,o.mdx)("inlineCode",{parentName:"p"},"/etc/gitconfig")," which recursively includes other config files) which were written by various systems (rpms, Chef, tools, etc).  This became unwieldy as the logic that decides which configs are used was distributed across many systems and services, and the order of precedence for the various config files was fragile."),(0,o.mdx)("p",null,"To make configuration more scalable, we unified all configuration into an internal dynamic configuration system, cleverly called ",(0,o.mdx)("inlineCode",{parentName:"p"},"dynamicconfig"),".  This moved most configuration decisions from across the company into code in a single part of the code base where it could be reasoned about as a cohesive whole.  For configs that need to change frequently, like a hotfix remediation or a rollout, we are able to query an internal configuration server for a signed blob of configuration. This remote blob contains a simple JSON decision-tree DSL which the client then executes to determine which configs should be applied to this particular repository."),(0,o.mdx)("p",null,"Both the in-code and the remote portions of the configuration allow conditionally enabling configs based on operating system, data center, user, repository, tier, machine shard, user shard, time shard, etc.  This allows us to rollout new features to particular machines or users, or to an automatically increasing percentage of users over time.  This flexibility has been key to letting Sapling move fast, as we can quickly release or rollback new features, and get feedback in an incremental fashion."),(0,o.mdx)("p",null,"Note, this dynamic configuration system is internal to Meta and does not apply to the open source release. No remote configs are downloaded for an open source Sapling build.  The code for ",(0,o.mdx)("inlineCode",{parentName:"p"},"dynamicconfig")," is not currently visible in the repository as it contains internal configuration information. If external groups are interested in similar capabilities we could potentially make the capability public."),(0,o.mdx)("h3",{id:"incremental-migrations"},"Incremental migrations"),(0,o.mdx)("p",null,"Being able to make incremental breaking changes on an in-production system was a critical piece of making Sapling scale within Meta. Distributed source control repositories are particularly difficult structures to change because:"),(0,o.mdx)("ol",null,(0,o.mdx)("li",{parentName:"ol"},"The contents are recursively hashed and the hashes are highly intertwined. Changing one byte changes every hash in the repository from there on."),(0,o.mdx)("li",{parentName:"ol"},"The data is widely distributed so a migration has to happen on many machines and there is no single source of truth.")),(0,o.mdx)("p",null,"This makes incremental migrations hard, since changing anything in the repository affects all the hashes and since everyone\u2019s individual copy of the repo will need to be migrated."),(0,o.mdx)("p",null,"Within Meta, these migrations fell into two categories: repository merges and format migrations."),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Repository Merges")),(0,o.mdx)("p",null,"Accomplishing repository merges involving thousands of people deserves a blog post of its own.  At a high level though, we developed server-side capabilities that let us \u201cbind\u201d directories in two repositories together so that any change to one was atomically applied to the other repository as well.  These bindings could be done either for the whole repository, or for individual directories in a repository.  This allowed us to make the contents of one repo available in another repo without any users having to immediately migrate. With the source control portion of the migration done transparently, the migration of users and tools could be done incrementally and in a way that was easy to rollback from.  Once all users and tools had migrated, we could shut down the old repository and remove the bindings."),(0,o.mdx)("p",null,(0,o.mdx)("strong",{parentName:"p"},"Format Migrations")),(0,o.mdx)("p",null,"Changing the hash scheme of the repository or the on-disk storage formats was particularly tricky since it meant migrating every single repository on every single machine for every single engineer.  These migrations generally required writing to both the new and the old format for a while, often auditing that the results were equivalent, before turning off the old format.  This required strong metrics (see below) to guarantee that the change had rolled out widely enough and taken effect on almost all the machines. It also required strong guarantees about the ability to roll new versions of the Sapling package to all machines.  Internally we deploy new Sapling packages on a continuous basis, and prevent the execution of packages that are too old."),(0,o.mdx)("p",null,"Hash scheme changes, while rare, required the additional step of maintaining a mapping between the new and the old hash scheme, and being able to validate past hashes which still used the old scheme."),(0,o.mdx)("h3",{id:"metrics-and-logging"},"Metrics and logging"),(0,o.mdx)("p",null,"Having real-time metrics on source control commands is critical for maintaining and improving the source control experience within Meta. Internally, we upload a wide variety of metrics for every Sapling command that is run, from command duration, to time waiting on other services, to number of files changed, network throughput, error traces, and more. This lets us not only keep an eye on long-term performance and reliability trends, but enables us to see the impact of current rollouts on performance and catch regressions before they affect everyone."),(0,o.mdx)("p",null,"The metrics are also useful for debugging individual developer issues.  If an engineer comes to us saying a given command failed yesterday, we\u2019re able to look at the log and see exactly what Sapling commands ran around that time, where the commands spent their time, and how they exited.  By combining the logs with Commit Cloud, the internal service that backs up every commit as it is made, we\u2019re often able to reproduce the exact situation the engineer experienced, without needing further information from the engineer."),(0,o.mdx)("p",null,"Note, none of this applies to the open source release.  Neither metrics nor commits are uploaded from the open source Sapling builds. These logging and metrics tools are strictly internal to Meta."))}h.isMDXComponent=!0}}]);